--- 
# TinyTapeout project information
project:
  wokwi_id:    0        # If using wokwi, set this to your project's ID

# If using an HDL, set wokwi_id as 0 and uncomment and list your source files here. 
# Source files must be in ./src and you must list each source file separately
  source_files:        
    - lfsr4.v
    - tt04_sahrdaya_lfsr.v
  top_module:  "tt04_sahrdaya_lfsr"      # put the name of your top module here, make it unique by prepending your github username

# How many tiles your design occupies? A single tile is about 167x108 uM.
  tiles: "1x1"    # Valid values: 1x1, 1x2, 2x2, 4x2 or 8x2

# Keep a track of the submission yaml
yaml_version: 4

# As everyone will have access to all designs, try to make it easy for someone new to your design to know what
# it does and how to operate it. This info will be automatically collected and used to make a datasheet for the chip.
#
# Here is a great example: https://github.com/davidsiaw/tt02-davidsiaw-stackcalc/blob/38c5647f83aad2aec675d566aa3d67b98f0aac81/info.yaml
documentation: 
  author:       "Arun A V"
  title:        "lfsr random number generator"
  language:     "Verilog"
  description:  "4-bit Linear Feedback Shift Register with configurable feedback polynomials based on the `mod` input, and it resets to the initial state when `reset` is asserted."

# Longer description of how the project works. You can use standard markdown format.
  how_it_works:
- **Clock and Reset Control:**
  - The module operates synchronously with a clock signal (`clk`) and includes an asynchronous reset signal (`reset`) to reset the LFSR to a known initial state.
  
- **LFSR Operation:**
  - The core of this module is the 4-bit LFSR, which consists of four flip-flops representing a shift register. It generates a pseudo-random sequence of 4 bits.
  - The LFSR's state is updated on the positive edge of the clock signal (`clk`).
  
- **Feedback Polynomials:**
  - The module provides flexibility by allowing the user to select one of several feedback polynomials using the `mod` input (a 3-bit input).
  - Different feedback polynomials change the behavior of the LFSR, resulting in different pseudo-random sequences.
  
- **Reset Behavior:**
  - When the `reset` signal is asserted (high), the LFSR is reset to a predefined initial state, `4'b1010`. This ensures a known starting point for the pseudo-random sequence.
  
- **Feedback Logic:**
  - Depending on the value of `mod`, the module employs specific feedback logic to generate the next state of the LFSR:
    - For example, when `mod` is 0, it uses the feedback polynomial `x^3 + x + 1`, updating the LFSR accordingly.
    - Different `mod` values correspond to distinct feedback polynomials, offering diverse sequence generation capabilities.
  
- **Output:**
  - The output of the LFSR is available as a 4-bit signal `lfsr`.
  
This Verilog module provides a versatile and configurable LFSR implementation that can be employed in various digital design applications, including pseudo-random sequence generation, data scrambling, and more. The choice of feedback polynomial through the `mod` input allows for customization of the LFSR's behavior, making it a valuable component in digital circuit design.
# Instructions on how someone could test your project, include things like what buttons do what and how to set the clock if needed
  how_to_test:
1. **Clock Input Setup:**
   - Ensure that you have a clock signal (`clk`) with a frequency of 10 MHz available. If you don't have an external clock source, you can use a clock signal generator or simulate the module using a Verilog simulator with an appropriate clock signal.
2. **Reset Control:**
   - The module includes an asynchronous reset signal (`reset`).
   - To start the testing process, you can initially assert the `reset` signal (set it to '1') to ensure the LFSR is in a known initial state.
3. **Configuration via `mod` Input:**
   - The `mod` input (a 3-bit input) allows you to configure the feedback polynomial of the LFSR and, consequently, its behavior.
   - Experiment with different values for the `mod` input to see how it affects the LFSR's output:
     - Set `mod` to 0, 1, 2, 3, 4, 5, or 6 to choose from different predefined feedback polynomials.
     - Observe how the LFSR generates pseudo-random sequences based on the selected feedback polynomial.
4. **Observing Output:**
   - The output of the LFSR is available as a 4-bit signal `lfsr`.
   - Connect `lfsr` to any suitable output device or use it as needed in your larger digital design.
5. **Clock Generation or Simulation:**
   - Ensure that the clock signal (`clk`) continues to run during your testing. If you're simulating the module, advance the simulation time to observe changes in the LFSR output over time.
6. **Counting Behavior:**
   - With the reset initially asserted and `mod` set to a specific value (e.g., 0), observe how the LFSR behaves.
   - After releasing the reset signal, the LFSR should start counting. For example, with `mod` set to 0, it will count up sequentially, producing a new 4-bit value on `lfsr` every clock cycle.
   - If `mod` is changed to different values, the counting behavior may change based on the selected feedback polynomial.
7. **Testing Variations:**
   - Experiment with different `mod` values and clock frequencies to explore the versatility of the LFSR in generating various pseudo-random sequences or patterns.
By following these instructions, you can effectively test and observe the behavior of the `lfsr4` Verilog module, allowing you to understand how the LFSR generates sequences based on different feedback polynomials and configurations.
# A description of what the inputs do (e.g. red button, SPI CLK, SPI MOSI, etc).
  inputs:               
    - mod bit 0
    - mod bit 1
    - mod bit 2
    - mod bit 3
    - clk
# A description of what the outputs do (e.g. status LED, SPI MISO, etc)
  outputs:
    - output bit 0
    - output bit 1
    - output bit 2
    -output bit 3


# The following fields are optional
  tag:          "timer, test"      # comma separated list of tags: test, encryption, experiment, clock, animation, utility, industrial, pwm, fpga, alu, microprocessor, risc, riscv, sensor, signal generator, fft, filter, music, bcd, sound, serial, timer, random number generator, calculator, decoder, counter, puzzle, multiplier, game, oscillator,
  external_hw:  ""      # Describe any external hardware needed
  discord:      "mattvenn"      # Your discord handle, used for communication and automatically assigning tapeout role after a submission
  doc_link:     ""      # URL to longer form documentation, eg the README.md in your repository
  clock_hz:     10000000       # Clock frequency in Hz (if required)
  picture:      ""      # relative path to a picture in your repository
